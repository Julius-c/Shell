# 这是一个简化版的Linux Shell
## 所有命令参数都须以空格分开!

### 主要功能说明
1. 该project的可执行文件为`njush`，源代码全部在`shell.c`中，输入`make`即可运行`njush`。
2. 为保证该shell的正确性，每执行一条命令都与`/bin/bash`对照。
3. 等待输入时显示提示符`NJUSH:~$ `。
4. 输入`help`可查看内置命令的说明。
    1. `exit`: 清理资源退出程序
    2. `cd [dir]`: 改变当前工作目录，默认有且只有一个参数。
    3. `history [-c] [number]`: 简化的bash history命令。
    4. `!!`: 执行最近一条命令。
    5. `!String`: 执行历史命令中最近的以String开头的命令。
    ...
5. 支持多个(IO重定向)进程以及内置命令之间的管道。
    1. 如`ls -l | grep njush | wc -l > junk`。
    2. 如`sleep 10 | sleep 10 | sleep 10 > empty`。
    3. 如`cd .. | history > a.txt | ls > b.txt`。
    4. 如`!! > junk | !ls | less`。
6. 支持前台和后台进程正常工作。
    1. 如`sleep 10 | sleep 10 | sleep 10 &`。
7. 使用gcc编译源码时使用`-Wall`显示所有警告。

### 代码思路说明
1. 一次读取命令执行过程如下。
    1. 读取一行输入，单独处理`exit`。
    2. 将`!!`和`!String`替换成相应命令。
    3. 判断是否需要后台执行，改变flag，去掉`&`。
    4. 处理完成将其插入链表。
    5. 根据管道符`|`将一行命令拆分成多个命令及其参数，单独处理无管道内置命令。
    6. 建立管道，fork进程分别执行，主进程等待。
2. 内置命令的实现相对容易。
    1. 利用双向链表实现`history`。
    2. 利用`chdir()`实现`cd`。
    3. 利用字符串匹配、拼接实现`!!`和`!String`。
    4. 归还链表内存空间实现`exit`。
    5. 建立内置命令表以实现`help`和查找执行操作。
3. 管道多进程、IO重定向。
    1. 用`redirect(argv[], index)`函数处理IO重定向。
    2. 用`_if_built_in(token)`判断是否为内置命令。
        1. 内置命令通过`cmd_table[id].handler(file)`执行，执行完毕立即退出该子进程。
        2. 其他命令通过`execvp(file, argv[])`执行。
    3. 用`execute(args)`处理管道。
        1. 分为首管道、中间管道、终管道三类处理。
        2. 每类中内置命令单独处理。

### 有待改进说明
1. 用于测试的命令有限。
2. 处理后台进程时会产生僵尸进程。
